}
}
}
sample_window_size <- 3
sample_size <- 20
extra_fit_values <- 3
get_full_sample(df)
# Create list of sample_size number of samples
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
View(sample_data)
# Create window + empty values for gaze data version
interp_sample_data <- sample_data
for (i in 1:sample_size) {
# Referencing the sample_window frames to turn them NA
interp_sample_data[[i]][(extra_fit_values + 1):(extra_fit_values + sample_window_size), focused_columns_start:focused_columns_end] <- NA
}
View(interp_sample_data)
View(interp_sample_data)
interp_sample_data[[1]][["gaze_0_x"]]
# Spline interpolate missing values
for (i in 1:sample_size){
for (j in focused_columns_start:focused_columns_end) {
interp_sample_data[[i]][,j] <- spline(interp_sample_data[[i]]$frame, as.numeric(interp_sample_data[[i]][,j]), xout = head(interp_sample_data[[i]]$frame, n=1):tail(interp_sample_data[[i]]$frame, n=1), method = "fmm")$y
}
}
View(interp_sample_data)
# Randomly select subject data from list of subject file names
list_subjects <- c("SING1005_P1_sing_V2_mask_DG_06-29-2021_L")
df <- read.csv(paste("~/Downloads/", sample(list_subjects, 1), ".csv", sep = ""))
focused_columns_start <- 6 # first column of column set to sample from
focused_columns_end <- 13 # last column of column set to sample from
# Function which returns correlations between sampled data (n = sample_size)
# in chunks of size "sample_window_size" and their spline interpolations
# extra_fit_values gives the number of data points to "help" with interpolation outside the interpolation window on each side
spline_interpolation <- function(sample_window_size, sample_size, extra_fit_values) {
# Find randomly selected window to interpolate with length sample_window_size
get_full_sample <- function(df) {
index <- c(1:length(df$frame))
for (k in 1:1000) {
sample_start <- sample(index,1)
# reduce sample_window_size by 1 to begin at index and still have correct window size
# sample window is increased by 2 * the # of extra_fit_values for spline interpolation
sample_indexes <- c((sample_start - extra_fit_values):(sample_start + (sample_window_size - 1) + extra_fit_values))
# Checks if the extra_fit rows in a column are all the same (would create standard deviation of 0)
check_list <- c()
pre_window <- c(sample_indexes[1:extra_fit_values])
post_window <- c(sample_indexes[(extra_fit_values + sample_window_size + 1):(length(sample_indexes))])
extra_window <- c(pre_window, post_window)
for (i in focused_columns_start:focused_columns_end) {
if (all(df[sample_indexes[1], i] == df[extra_window, i])) {
check_list[i-(focused_columns_start - 1)] <- TRUE
} else {
check_list[i-(focused_columns_start - 1)] <- FALSE
}
}
# This if statement checks if the sample contains only frames where success = 1
# AND if the starting value of a column equals the ending value (messes with linear interpolation)
if (!any(df$sucess[sample_indexes] == 0) &&
!any(check_list)) {
return(df[sample_indexes,])
break
} else {
next
}
}
}
# Create list of sample_size number of samples
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
# Create window + empty values for gaze data version
interp_sample_data <- sample_data
for (i in 1:sample_size) {
# Referencing the sample_window frames to turn them NA
interp_sample_data[[i]][(extra_fit_values + 1):(extra_fit_values + sample_window_size), focused_columns_start:focused_columns_end] <- NA
}
# Spline interpolate missing values
for (i in 1:sample_size){
for (j in focused_columns_start:focused_columns_end) {
interp_sample_data[[i]][,j] <- spline(interp_sample_data[[i]]$frame, as.numeric(interp_sample_data[[i]][,j]), xout = head(interp_sample_data[[i]]$frame, n=1):tail(interp_sample_data[[i]]$frame, n=1), method = "fmm")$y
}
}
# create correlation matrix
# 8 columns for number of gaze data columns
corr_matrix_spline <- matrix(NA, nrow = sample_size, ncol = 8)
for (i in 1:sample_size) {
for (j in focused_columns_start:focused_columns_end) {
corr_matrix_spline[i,j - 5] <- cor(sample_data[[i]][,j],interp_sample_data[[i]][,j])
}
}
corr_matrix_spline <- data.frame(corr_matrix_spline)
colnames(corr_matrix_spline) <- colnames(sample_data[[1]][focused_columns_start:focused_columns_end])
return(corr_matrix_spline)
}
corr_matrix_spline <- spline_interpolation(3, 200, 3)
View(corr_matrix_spline)
# Column means
column_means <- c()
for (i in 1:length(colnames(corr_matrix_spline))) {
column_means[i] <- mean(as.numeric(corr_matrix_spline[, i]))
}
print(column_means)
View(corr_matrix_spline)
get_full_sample <- function(df) {
index <- c(1:length(df$frame))
for (i in 1:1000) {
sample_start <- sample(index,1)
# reduce sample_window_size by 1 to begin at index and still have correct window size, add 2 for interpolation start and end points
sample_indexes <- c(sample_start:(sample_start + (sample_window_size - 1) + 2))
# Checks if the starting point and ending point of the sample frames are the same (messes with linear interpolation)
check_list <- c()
for (i in focused_columns_start:focused_columns_end) {
if (df[sample_indexes[1], i] == df[sample_indexes[length(sample_indexes)], i]) {
check_list[i-5] <- TRUE
} else {
check_list[i-5] <- FALSE
}
}
# This if statement checks if the sample contains only frames where success = 1
# AND if the starting value of a column equals the ending value (messes with linear interpolation)
if (!any(df$sucess[sample_indexes] == 0) &&
!any(check_list)) {
return(df[sample_indexes,])
break
} else {
next
}
}
}
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
sample_size <- 20
sample_window_size <- 3
# Create list of sample_size number of samples
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
# Randomly select subject data from list of subject file names
list_subjects <- c("SING1005_P1_sing_V2_mask_DG_06-29-2021_L")
df <- read.csv(paste("~/Downloads/", sample(list_subjects, 1), ".csv", sep = ""))
focused_columns_start <- 6 # first column of column set to sample from
focused_columns_end <- 13 # last column of column set to sample from
# Function which returns correlations between sampled data (n = sample_size)
# in chunks of size "sample_window_size" and their linear interpolations
linear_interpolation <- function(sample_window_size, sample_size) {
# Find randomly selected window to interpolate with length sample_window_size
get_full_sample <- function(df) {
index <- c(1:length(df$frame))
for (i in 1:1000) {
sample_start <- sample(index,1)
# reduce sample_window_size by 1 to begin at index and still have correct window size, add 2 for interpolation start and end points
sample_indexes <- c(sample_start:(sample_start + (sample_window_size - 1) + 2))
# Checks if the starting point and ending point of the sample frames are the same (messes with linear interpolation)
check_list <- c()
for (i in focused_columns_start:focused_columns_end) {
if (df[sample_indexes[1], i] == df[sample_indexes[length(sample_indexes)], i]) {
check_list[i-5] <- TRUE
} else {
check_list[i-5] <- FALSE
}
}
# This if statement checks if the sample contains only frames where success = 1
# AND if the starting value of a column equals the ending value (messes with linear interpolation)
if (!any(df$sucess[sample_indexes] == 0) &&
!any(check_list)) {
return(df[sample_indexes,])
break
} else {
next
}
}
}
# Create list of sample_size number of samples
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
# Create window + empty values for gaze data version
interp_sample_data <- sample_data
for (i in 1:sample_size) {
# [1:(sample_window_size + 1),] denotes the values in between the interpolation points at the beginning and end of a column
interp_sample_data[[i]][2:(sample_window_size + 1), focused_columns_start:focused_columns_end] <- NA
}
# Code for applying the different methods to the empty values for the gaze data
# Linear interpolation
linear_interp <- function(a, b, n) {
seq <- seq(from = a, to = b, length.out = n)
return(seq[-c(1,length(seq))])
}
# apply linear interpolation
for (i in 1:sample_size) {
for (j in focused_columns_start:focused_columns_end) {
interp_sample_data[[i]][2:(sample_window_size + 1), j] <- linear_interp(interp_sample_data[[i]][1, j], interp_sample_data[[i]][sample_window_size + 2, j], sample_window_size + 2)
}
}
# create correlation matrix
# 8 columns for number of gaze data columns
corr_matrix <- matrix(NA, nrow = sample_size, ncol = 8)
for (i in 1:sample_size) {
for (j in focused_columns_start:focused_columns_end) {
corr_matrix[i,j - 5] <- cor(sample_data[[i]][,j],interp_sample_data[[i]][,j])
}
}
corr_matrix <- data.frame(corr_matrix)
colnames(corr_matrix) <- colnames(sample_data[[1]][focused_columns_start:focused_columns_end])
return(corr_matrix)
}
corr_matrix_linear <- linear_interpolation(3, 200)
# Function which returns correlations between sampled data (n = sample_size)
# in chunks of size "sample_window_size" and their spline interpolations
# extra_fit_values gives the number of data points to help with interpolation algorithm outside the interpolation window on each side
spline_interpolation <- function(sample_window_size, sample_size, extra_fit_values) {
# Find randomly selected window to interpolate with length sample_window_size
get_full_sample <- function(df) {
index <- c(1:length(df$frame))
for (k in 1:1000) {
sample_start <- sample(index,1)
# reduce sample_window_size by 1 to begin at index and still have correct window size
# sample window is increased by 2 * the # of extra_fit_values for spline interpolation
sample_indexes <- c((sample_start - extra_fit_values):(sample_start + (sample_window_size - 1) + extra_fit_values))
# Checks if the extra_fit rows in a column are all the same (would create standard deviation of 0)
check_list <- c()
pre_window <- c(sample_indexes[1:extra_fit_values])
post_window <- c(sample_indexes[(extra_fit_values + sample_window_size + 1):(length(sample_indexes))])
extra_window <- c(pre_window, post_window)
for (i in focused_columns_start:focused_columns_end) {
if (all(df[sample_indexes[1], i] == df[extra_window, i])) {
check_list[i-(focused_columns_start - 1)] <- TRUE
} else {
check_list[i-(focused_columns_start - 1)] <- FALSE
}
}
# This if statement checks if the sample contains only frames where success = 1
# AND if the starting value of a column equals the ending value (messes with linear interpolation)
if (!any(df$sucess[sample_indexes] == 0) &&
!any(check_list)) {
return(df[sample_indexes,])
break
} else {
next
}
}
}
# Create list of sample_size number of samples
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
# Create window + empty values for gaze data version
interp_sample_data <- sample_data
for (i in 1:sample_size) {
# Referencing the sample_window frames to turn them NA
interp_sample_data[[i]][(extra_fit_values + 1):(extra_fit_values + sample_window_size), focused_columns_start:focused_columns_end] <- NA
}
# Spline interpolate missing values
for (i in 1:sample_size){
for (j in focused_columns_start:focused_columns_end) {
interp_sample_data[[i]][,j] <- spline(interp_sample_data[[i]]$frame, as.numeric(interp_sample_data[[i]][,j]), xout = head(interp_sample_data[[i]]$frame, n=1):tail(interp_sample_data[[i]]$frame, n=1), method = "fmm")$y
}
}
# create correlation matrix
# 8 columns for number of gaze data columns
corr_matrix_spline <- matrix(NA, nrow = sample_size, ncol = 8)
for (i in 1:sample_size) {
for (j in focused_columns_start:focused_columns_end) {
corr_matrix_spline[i,j - 5] <- cor(sample_data[[i]][,j],interp_sample_data[[i]][,j])
}
}
corr_matrix_spline <- data.frame(corr_matrix_spline)
colnames(corr_matrix_spline) <- colnames(sample_data[[1]][focused_columns_start:focused_columns_end])
return(corr_matrix_spline)
}
corr_matrix_spline <- spline_interpolation(3, 200, 3)
# Column means
column_means <- c()
for (i in 1:length(colnames(corr_matrix))) {
column_means[i] <- mean(as.numeric(corr_matrix[, i]))
}
column_means <- c()
for (i in 1:length(colnames(corr_matrix_linear))) {
column_means[i] <- mean(as.numeric(corr_matrix_linear[, i]))
}
print(column_means)
# Column means
column_means <- c()
for (i in 1:length(colnames(corr_matrix_spline))) {
column_means[i] <- mean(as.numeric(corr_matrix_spline[, i]))
}
print(column_means)
corr_matrix_spline <- spline_interpolation(4, 200, 3)
column_means <- c()
for (i in 1:length(colnames(corr_matrix_spline))) {
column_means[i] <- mean(as.numeric(corr_matrix_spline[, i]))
}
print(column_means)
corr_matrix_spline <- spline_interpolation(5, 200, 3)
column_means <- c()
for (i in 1:length(colnames(corr_matrix_spline))) {
column_means[i] <- mean(as.numeric(corr_matrix_spline[, i]))
}
print(column_means)
gc()
# Randomly select subject data from list of subject file names
list_subjects <- c("SING1005_P1_sing_V2_mask_DG_06-29-2021_L")
df <- read.csv(paste("~/Downloads/", sample(list_subjects, 1), ".csv", sep = ""))
focused_columns_start <- 6 # first column of column set to sample from
focused_columns_end <- 13 # last column of column set to sample from
# Function which returns correlations between sampled data (n = sample_size)
# in chunks of size "sample_window_size" and their linear interpolations
linear_interpolation <- function(sample_window_size, sample_size) {
# Find randomly selected window to interpolate with length sample_window_size
get_full_sample <- function(df) {
index <- c(1:length(df$frame))
for (i in 1:1000) {
sample_start <- sample(index,1)
# reduce sample_window_size by 1 to begin at index and still have correct window size, add 2 for interpolation start and end points
sample_indexes <- c(sample_start:(sample_start + (sample_window_size - 1) + 2))
# Checks if the starting point and ending point of the sample frames are the same (messes with linear interpolation)
check_list <- c()
for (i in focused_columns_start:focused_columns_end) {
if (df[sample_indexes[1], i] == df[sample_indexes[length(sample_indexes)], i]) {
check_list[i-5] <- TRUE
} else {
check_list[i-5] <- FALSE
}
}
# This if statement checks if the sample contains only frames where success = 1
# AND if the starting value of a column equals the ending value (messes with linear interpolation)
if (!any(df$sucess[sample_indexes] == 0) &&
!any(check_list)) {
return(df[sample_indexes,])
break
} else {
next
}
}
}
# Create list of sample_size number of samples
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
# Create window + empty values for gaze data version
interp_sample_data <- sample_data
for (i in 1:sample_size) {
# [1:(sample_window_size + 1),] denotes the values in between the interpolation points at the beginning and end of a column
interp_sample_data[[i]][2:(sample_window_size + 1), focused_columns_start:focused_columns_end] <- NA
}
# Code for applying the different methods to the empty values for the gaze data
# Linear interpolation
linear_interp <- function(a, b, n) {
seq <- seq(from = a, to = b, length.out = n)
return(seq[-c(1,length(seq))])
}
# apply linear interpolation
for (i in 1:sample_size) {
for (j in focused_columns_start:focused_columns_end) {
interp_sample_data[[i]][2:(sample_window_size + 1), j] <- linear_interp(interp_sample_data[[i]][1, j], interp_sample_data[[i]][sample_window_size + 2, j], sample_window_size + 2)
}
}
# create correlation matrix
# 8 columns for number of gaze data columns
corr_matrix <- matrix(NA, nrow = sample_size, ncol = 8)
for (i in 1:sample_size) {
for (j in focused_columns_start:focused_columns_end) {
corr_matrix[i,j - 5] <- cor(sample_data[[i]][,j],interp_sample_data[[i]][,j])
}
}
corr_matrix <- data.frame(corr_matrix)
colnames(corr_matrix) <- colnames(sample_data[[1]][focused_columns_start:focused_columns_end])
return(corr_matrix)
}
# Function which returns correlations between sampled data (n = sample_size)
# in chunks of size "sample_window_size" and their spline interpolations
# extra_fit_values gives the number of data points to help with interpolation algorithm outside the interpolation window on each side
spline_interpolation <- function(sample_window_size, sample_size, extra_fit_values) {
# Find randomly selected window to interpolate with length sample_window_size
get_full_sample <- function(df) {
index <- c(1:length(df$frame))
for (k in 1:1000) {
sample_start <- sample(index,1)
# reduce sample_window_size by 1 to begin at index and still have correct window size
# sample window is increased by 2 * the # of extra_fit_values for spline interpolation
sample_indexes <- c((sample_start - extra_fit_values):(sample_start + (sample_window_size - 1) + extra_fit_values))
# Checks if the extra_fit rows in a column are all the same (would create standard deviation of 0)
check_list <- c()
pre_window <- c(sample_indexes[1:extra_fit_values])
post_window <- c(sample_indexes[(extra_fit_values + sample_window_size + 1):(length(sample_indexes))])
extra_window <- c(pre_window, post_window)
for (i in focused_columns_start:focused_columns_end) {
if (all(df[sample_indexes[1], i] == df[extra_window, i])) {
check_list[i-(focused_columns_start - 1)] <- TRUE
} else {
check_list[i-(focused_columns_start - 1)] <- FALSE
}
}
# This if statement checks if the sample contains only frames where success = 1
# AND if the starting value of a column equals the ending value (messes with linear interpolation)
if (!any(df$sucess[sample_indexes] == 0) &&
!any(check_list)) {
return(df[sample_indexes,])
break
} else {
next
}
}
}
# Create list of sample_size number of samples
sample_data <- list()
for (i in 1:sample_size) {
sample_data[[i]] <- get_full_sample(df)
}
# Create window + empty values for gaze data version
interp_sample_data <- sample_data
for (i in 1:sample_size) {
# Referencing the sample_window frames to turn them NA
interp_sample_data[[i]][(extra_fit_values + 1):(extra_fit_values + sample_window_size), focused_columns_start:focused_columns_end] <- NA
}
# Spline interpolate missing values
for (i in 1:sample_size){
for (j in focused_columns_start:focused_columns_end) {
interp_sample_data[[i]][,j] <- spline(interp_sample_data[[i]]$frame, as.numeric(interp_sample_data[[i]][,j]), xout = head(interp_sample_data[[i]]$frame, n=1):tail(interp_sample_data[[i]]$frame, n=1), method = "fmm")$y
}
}
# create correlation matrix
# 8 columns for number of gaze data columns
corr_matrix_spline <- matrix(NA, nrow = sample_size, ncol = 8)
for (i in 1:sample_size) {
for (j in focused_columns_start:focused_columns_end) {
corr_matrix_spline[i,j - 5] <- cor(sample_data[[i]][,j],interp_sample_data[[i]][,j])
}
}
corr_matrix_spline <- data.frame(corr_matrix_spline)
colnames(corr_matrix_spline) <- colnames(sample_data[[1]][focused_columns_start:focused_columns_end])
return(corr_matrix_spline)
}
sample_window_size_c <- c(1:32)
for (i in 1:length(sample_window_size_c)) {
tmp <- linear_interpolation(sample_window_size_c[i], 200)
tmp2 <- spline_interpolation(sample_window_size_c[i], 200, 3)
current_linear <- data.frame(id = filename, method = "linear", window_size = sample_window_size_c[i], cor = rowMeans(tmp[,c("gaze_angle_x","gaze_angle_y")]))
current_spline <- data.frame(id = filename, method = "spline", window_size = sample_window_size_c[i], cor = rowMeans(tmp2[,c("gaze_angle_x","gaze_angle_y")]))
# frames within chunk, as a function of chunk size
if (i == 1) {
for_plot <- rbind(current_linear, current_spline)
} else {
for_plot = rbind(for_plot,rbind(current_linear, current_spline))
}
}
for (i in 1:length(sample_window_size_c)) {
tmp <- linear_interpolation(sample_window_size_c[i], 200)
tmp2 <- spline_interpolation(sample_window_size_c[i], 200, 3)
current_linear <- data.frame(method = "linear", window_size = sample_window_size_c[i], cor = rowMeans(tmp[,c("gaze_angle_x","gaze_angle_y")]))
current_spline <- data.frame(method = "spline", window_size = sample_window_size_c[i], cor = rowMeans(tmp2[,c("gaze_angle_x","gaze_angle_y")]))
# add id = filename
# frames within chunk, as a function of chunk size
if (i == 1) {
for_plot <- rbind(current_linear, current_spline)
} else {
for_plot = rbind(for_plot,rbind(current_linear, current_spline))
}
}
library(ggplot2)
corr_matrix_spline <- spline_interpolation(3, 200, 10)
corr_matrix_linear <- linear_interpolation(3, 200)
View(corr_matrix_linear)
View(corr_matrix_spline)
tmp <- linear_interpolation(sample_window_size_c[i], 200)
tmp2 <- spline_interpolation(sample_window_size_c[i], 200, 3)
current_linear <- data.frame(method = "linear", window_size = sample_window_size_c[i], cor = rowMeans(tmp[,c("gaze_angle_x","gaze_angle_y")]))
current_spline <- data.frame(method = "spline", window_size = sample_window_size_c[i], cor = rowMeans(tmp2[,c("gaze_angle_x","gaze_angle_y")]))
# add id = filename
if (i == 1) {
for_plot <- rbind(current_linear, current_spline)
} else {
for_plot = rbind(for_plot,rbind(current_linear, current_spline))
}
for (i in 1:length(sample_window_size_c)) {
tmp <- linear_interpolation(sample_window_size_c[i], 200)
tmp2 <- spline_interpolation(sample_window_size_c[i], 200, 3)
current_linear <- data.frame(method = "linear", window_size = sample_window_size_c[i], cor = rowMeans(tmp[,c("gaze_angle_x","gaze_angle_y")]))
current_spline <- data.frame(method = "spline", window_size = sample_window_size_c[i], cor = rowMeans(tmp2[,c("gaze_angle_x","gaze_angle_y")]))
# add id = filename
# frames within chunk, as a function of chunk size
if (i == 1) {
for_plot <- rbind(current_linear, current_spline)
} else {
for_plot = rbind(for_plot,rbind(current_linear, current_spline))
}
}
ggplot(for_plot, aes(x =window_size, y = cor, colour = method)) + stat_summary(geom = "line")
?lm()
?poly()
vec <- c(1,2,3,4,5)
poly(vec)
vec <- c(1:20)
poly(vec)
lm(y ~ poly(vec, 3, raw = TRUE))
lm(vec ~ poly(vec, 3, raw = TRUE))
x_known <- c(1:5, 11:15)
y_known <- c(3,13,17,19,20,25,26,30,35,40)
x_missing <- 6:10
fit <- lm(y_known ~ poly(x_known, degree = 9, raw = TRUE))
View(fit)
y_missing <- predict(fit, newdata = data.frame(x_known = x_missing))
